Leads
Leads are the most important object in Close. They represent a company or organization and can contain contacts, tasks, opportunities, and activities. In fact, these other objects must be children of a Lead. You can think of a Lead in Close like both a "lead" and "account" in the terminology of some other CRMs.

When a lead is returned, its basic info as well as related tasks, opportunities, and custom fields are included. Activities are excluded and have to be fetched separately via the activities endpoint.

Custom fields that have a value are returned as custom.FIELD_ID, where FIELD_ID is the ID of the custom field (see Custom Fields for more details). Note that using the custom field dict is deprecated, and the field will be removed from the API.

When using the _fields parameter, specify custom to show all custom fields. Returning individual custom fields is currently not supported via _fields.

Smart Fields are not included in the response by default. If you'd like to include them, you can:

Fetch a specific Smart Field with ?_fields=smart_field_name,other_lead_field_names
Fetch all Lead fields and all Smart Fields with ?_fields=_all
To speed up your integration, we recommend that you only use the _all flag to discover what Smart Fields are available and then use ?_fields=specific,set,of,fields to return only the fields you need.

Filtering leads
To easily find Leads that match specific conditions, use the Advanced Filtering API.

List Leads
GET /lead/{?_limit, _skip, _fields}

Example Request/Response
Create a new lead.
POST /lead/

Contacts, addresses, and custom fields can all be nested in the lead. Currently, activities, tasks, and opportunities must be posted separately.

status and status_id (optional)

Optionally post either status or status_id (but not both). If neither property exists, the organization's default (first) status will be used when creating new leads.

(Recommended) Use status_id (like in the example payload), so that users can rename statuses in the UI without breaking your implementation.

Alternatively, you can post a status containing the label of an already-created status object.

custom.FIELD_ID (optional)

You can set custom fields by setting custom.FIELD_ID to the field value, where FIELD_ID is the ID of the custom field, e.g.:

{
    "custom.cf_v6S011I6MqcbVvB2FA5Nk8dr5MkL8sWuCiG8cUleO9c": "value",
    "custom.cf_8wtBWsdRU2Fur7GDnEeXQ7ra2Vu7R4hG1SNYdiEhh0F": "other value"
}
Note that if a custom field has accepts_multiple_values: true, the entire value will be replaced. For example, given a Lead has a Custom Choice Field with value ["A", "B"], adding choice "C" would mean setting the value to ["A", "B", "C"].

Note that using the custom field dict or the custom.FIELD_NAME syntax (instead of custom field IDs) is deprecated and will be removed from the API.

See the Custom Fields paragraph for more details.

Example Request/Response
Retrieve a single lead.
GET /lead/{id}/{?_fields}

Example Request/Response
Update an existing lead.
PUT /lead/{id}/

Supports non-destructive patches.

status:

See description for status and status_id in POST /lead/ above.

custom.FIELD_ID (optional)

See description for custom.FIELD_ID in POST /lead/ above.

Additionally, you can unset a single field by using { "custom.FIELD_ID": null }, e.g.:

{ "custom.cf_v6S011I6MqcbVvB2FA5Nk8dr5MkL8sWuCiG8cUleO9c": null }
If the custom field you are trying to update accepts multiple values, you can also specify .add or .remove as part of the field key to add/remove a single value to/from a list of values, e.g.:

{ "custom.cf_v6S011I6MqcbVvB2FA5Nk8dr5MkL8sWuCiG8cUleO9c.add": "Wednesday" }
adds "Wednesday" to the list of values which already exist on the given lead.

Example Request/Response
Delete a lead.
DELETE /lead/{id}/

Example Request/Response
Merge two leads.
POST /lead/merge/

For details and definitions of 'source' and 'destination', see the Merge Leads feature in the UI.

Activities
Activities belong to Leads and can represent any type of activity that was performed on a Lead or its Contacts (e.g. Calls, Emails, Notes, etc.).

List or filter all activity types.
GET /activity/{?lead_id, user_id, user_id__in, contact_id, contact_id__in, _type, _type__in, date_created__gt, date_created__lt, _fields}

To list only a specific activity type (e.g., only Call or LeadStatusChange), use the other resources listed separately. When querying activities for a single lead (using the lead_id parameter), you can ask for multiple activity types using _type__in.

When listing Custom Activities, _type and _type__in can include Custom Activity Type ids (e.g. actitype_1h5m6uHM9BZOpwVhyRJb4Y) to filter by a specific custom activity type or Custom to list custom activities of any type.

The following filtering parameters can only be used for listing activities on a single lead (using the lead_id parameter): user_id, user_id__in, contact_id, contact_id__in, _type, _type__in.

thread_emails parameter:

(Default) when this parameter is not present, Email objects will be returned for each email message.
A value of true will return EmailThread objects representing email conversations. Stripped-down version of Email objects will also be returned.
A value of only will return EmailThread objects representing email conversations. Email objects will not be returned.

Tasks
Tasks are action items with a given date that are assigned to a sales rep.

Incomplete tasks (is_complete is false) show in the sales rep's inbox, whereas complete tasks (is_complete is true) are shown in the archive. Archived tasks of certain types are automatically deleted after a certain amount of time.

The date of a task represents the point in time of when the task is actionable and appears in the inbox. It can either be date-only (e.g. 2015-01-05), or a date time (e.g. 2015-01-10T05:00:00+00:00). When ordering tasks by date, date-only tasks are ordered before any date-time tasks at the given date, taking the time zone (x-tz-offset) into account. For example, in Pacific Standard Time (x-tz-offset: -8) and ascending order, a task dated 2015-01-12 will appear before 2015-01-12T08:00:00, but after 2015-01-12T07:00:00. Some endpoints accept and return a due_date field, which is deprecated and shouldn't be used.

The type of a task is returned using the _type field, which can also be used to filter tasks. When not filtering by _type, only tasks of lead type are returned. All tasks can be shown using _type=all, and multiple task types can be filtered by passing the type names comma separated into _type__in (e.g. _type__in=missed_call,voicemail). Some task types have a corresponding object which is returned using the object_id and object_type params. The following is a list of task types and corresponding objects that exist:

lead: A to-do item/task for a given lead. Both object_type and object_id are null, since the lead is already returned in lead_id.
incoming_email: One or multiple incoming emails on an email thread. The object_type is emailthread, and object_id is the ID of the corresponding email thread. Multiple unread emails in one thread are consolidated into one task. The emails array contains a list of email activity IDs related to this task. The subject field contains the subject of the email thread.
email_followup: A reminder to follow up on a specific email you sent in the past and didn't get a response to. The object_type is emailthread, and object_id is the ID of the corresponding email thread. A reference to the email you sent originally is stored in email_id. The subject and body_preview fields contain data related the email you should follow up on.
missed_call: A missed call. The object_type is call, and object_id is the activity ID of the call that was missed. The phone field contains the phone number of the remote party, the local_phone field contains the number that was called.
answered_detached_call: A call from a number that isn't associated with any of the organization's contacts. The object_type is call, and object_id is the ID of the corresponding call. The phone field contains the phone number of the remote party.
voicemail: A voicemail. Just like missed_call, with the additional fields voicemail_duration and voicemail_url.
opportunity_due: Indicates that an opportunity is scheduled to close on this date. The object_type is opportunity, and object_id is the ID of the corresponding opportunity.
incoming_sms: An incoming SMS. The object_type is sms, and object_id is the ID of the corresponding SMS. The remote_phone field contains the phone number of the sender, the local_phone field contains the number that was texted. If incoming SMS is actually an MMS, it will have all the attachments in the attachments field: check the example response for what fields could be present there.
List or filter tasks.
GET /task/{?id, id__in, _type, lead_id, is_complete, date__{lt|gt|lte|gte}, date_created__{lt|gt|lte|gte}, assigned_to, view, _order_by}

The view parameter can be used to conveniently access the different task views. It accepts one of the following values:

inbox: Shows incomplete tasks up to the end of the user's day only (taking the time zone into account).
future: Shows incomplete tasks starting from the user's tomorrow only (taking the time zone into account).
archive: Shows complete tasks only.
The _order_by field allows ordering by date or date_created (descending order by prepending a minus, e.g. _order_by=-date).

Example Request/Response
Create a task.
POST /task/

Currently only tasks of type lead can be created, so the _type field may be omitted.

Example Request/Response
Bulk-update tasks.
PUT /task/{?...}

Any of the filters of the GET endpoint may be used. For example, to update multiple tasks with given IDs A, B and C, id__in=A,B,C would be passed.

Only the assigned_to, date and is_complete fields may be updated.

Example Request/Response
Fetch a task's details.
GET /task/{id}/

Example Request/Response
Update a task.
PUT /task/{id}/

The assigned_to, date (either a date or a date-time) and is_complete fields may be updated on all tasks. If the task type is lead, the text field may also be modified.

Example Request/Response
Delete a task.
DELETE /task/{id}/

SMS Templates
SMS Templates are predefined messages that can be used over and over again when sending SMS. They save time when sending sms one at a time via the Close UI.

List sms templates.
GET /sms_template/

Example Request/Response
Create an SMS template.
POST /sms_template/

Example Request/Response
Fetch an SMS template.
GET /sms_template/{id}/

Example Request/Response
Update an SMS template.
PUT /sms_template/{id}/

Example Request/Response
Delete an SMS template.
DELETE /sms_template/{id}/

Lead Statuses
Lead statuses are a customizable list of stages a Lead can be in.

List lead statuses for your organization.
GET /status/lead/

Example Request/Response
Create a new status that can be applied to leads.
POST /status/lead/

Example Request/Response
Rename a lead status.
PUT /status/lead/{status_id}/

Note: to update the status of a particular lead, see PUT /lead/{lead_id}/

Example Request/Response
Delete a lead status.
DELETE /status/lead/{status_id}/

You should make sure no leads are assigned this status, first.

Specifying Filter Parameters
Many resources accept filters and other parameters which can be simply passed in the GET query string. However, in certain cases, like filtering by a long list of IDs, URLs can potentially exceed the recommended maximum URL length (2000 characters). To prevent problems with long URLs, parameters can also be specified in a JSON-encoded dictionary in the request body under the _params key. Since GET requests with a request body are against the specification, we support the x-http-method-override HTTP header that lets you override the request method.

For example, the following two requests are equivalent:

Copy
curl -X POST
     -u apikey:
     -H 'content-type: application/json'
     -H 'x-http-method-override: GET'
     -d '{"_params": { "lead_id": "THE_LEAD_ID" }}'
     https://api.close.com/api/v1/activity/
Copy
curl -u apikey: https://api.close.com/api/v1/activity/?lead_id=THE_LEAD_ID
The x-http-method-override header can also be used for clients that have issues with request methods other than GET and POST.

Updating Specific Fields
In the Close API, every PUT request behaves as a patch. What it means is that you don't need to send all the fields with every request. For example, if only the title field changed for a specific Contact, there's no need to include the name field in the request.

Advanced Filtering
Tutorial
The Advanced Filtering API allows you to use arbitrary filters to find Leads or Contacts with specific attributes.

To use the Advanced Filtering API, make a POST request to /api/v1/data/search/ with your JSON filters in the request body. Let’s consider a simple example of finding all Contacts with CEOs you have on file in Close. The example POST request data with the query would look like this:

Copy
{
  "query": {
    "type": "and",
    "queries": [
      {
        "type": "object_type",
        "object_type": "contact"
      },
      {
        "type": "field_condition",
        "field": {
          "type": "regular_field",
          "object_type": "contact",
          "field_name": "title"
        },
        "condition": {
          "type": "text",
          "mode": "full_words",
          "value": "CEO"
        }
      }
    ]
  }
}
The request consists of a top level "and" query which combines two constraints on what would be returned:

An object_type query that tells the API that you’re interested in finding Contacts.
A field_condition query that asks for Contacts that have a title value containing a word "CEO".
Every query has a "type" that distinguishes the way you filter through objects.

The first part of the example query is "type": "object_type". It specifies that you only want objects of type Contact returned in the response.

The second part of the example query is "field_condition". Field condition queries specify the field you want to match against (in this case "title"), and the values you want to match it to (i.e. "CEO").

The field in this example is a "regular_field" named "title" on a "contact" object. There can be other kinds of fields as well, like Contact Custom Fields.

The field condition here is a simple "text" condition. It matches against the text "CEO", so any contact that have a title containing word "CEO" will be returned.

Here’s an example response:

Copy
{
  "data": [
    {
      "__object_type": "contact",
      "id": "cont_PtENYt1P6sRWkcnqoGnIj6hcZammGPdVbTXJWqdTvpV"
    },
    {
      "__object_type": "contact",
      "id": "cont_HjTcJFiNli2AKf5fioygQDVSpA9nJILI9SkKv3nBk0A"
    },
    {
      "__object_type": "contact",
      "id": "cont_LXQqW8mvD0BbCR6qhRPbzPZF7gCbXQIw6GD8vqKipss"
    }
  ],
  "cursor": null
}
More complex query
A more complicated example would be finding CEOs of SaaS companies that have at least one email address.

Copy
{
  "query": {
    "type": "and"
    "queries": [
      {
        "type": "object_type",
        "object_type": "contact"
      },
      {
        "type": "field_condition",
        "field": {
          "type": "regular_field",
          "object_type": "contact",
          "field_name": "emails_count"
        },
        "condition": {
          "type": "number_range",
          "gt": 1
        }
      },
      {
        "type": "field_condition",
        "field": {
          "type": "regular_field",
          "object_type": "contact",
          "field_name": "title"
        },
        "condition": {
          "type": "text",
          "mode": "full_words",
          "value": "CEO"
        }
      },
      {
        "type": "has_related",
        "this_object_type": "contact",
        "related_object_type": "lead",
        "related_query": {
          "type": "field_condition",
          "field": {
            "type": "custom_field",
            "custom_field_id": "cf_B57sofuEB7OBneH86SJctTr7hfiAiQcgkGRbAQfha0Z"
          },
          "condition": {
            "type": "term",
            "values": ["Software as a service"]
          },
          "negate": false
        }
      }
    ]
  }
}
In this query you can see several new concepts:

A different condition for a field that represents a "number_range" as opposed to just textual match. gt: 1 means greater than one.
A field type "custom_field" that references a Lead Custom Field by its id.
A "has_related" query that lets you match on data from a different related object rather than the one you want returned, in this case a Lead.
If the examples here don't cover your use case, check out Visual Query Builder for help with building a query structure tailored to your needs.

Visual Query Builder
Instead of composing the JSON query structure by hand, you can build your query visually on the Leads Page or Contacts page in Close app, and then copy the JSON query structure by clicking the triple-dot menu on the top right and selecting "Copy Filters".

Advanced Filtering

Output control
By default, the Advanced Filtering API only returns the IDs of the matched objects to improve performance. If you want to get more the data for the object, you will need to pass a _fields object to specify which fields you want returned for the object you're filtering for. For example:

Copy
{
  "query": ...,
  "_fields": {
    "contact": ["id", "name", "title"]
  }
}
The fields are exactly the same as ones in REST API for corresponding object types.

This results in the following:

Copy
{
  "data": [
    {
      "__object_type": "contact",
      "id": "cont_HjTcJFiNli2AKf5fioygQDVSpA9nJILI9SkKv3nBk0A",
      "name": "Bruce Wayne",
      "title": "The Dark Knight"
    },
    {
      "__object_type": "contact",
      "id": "cont_LXQqW8mvD0BbCR6qhRPbzPZF7gCbXQIw6GD8vqKipss",
      "name": "Steli Efti",
      "title": "CEO & Co-Founder"
    }
  ]
}
Results limit
If you want to only get first N results, you can specify a results limit.

Limiting results might be useful if you have 1000 objects but you want to act only on the first 100.

Copy
    {
      "query": ...,
      "results_limit": 100,
    }
Note that this limits the number returned in the overall result set and is separate from pagination.

Results count
Sometimes you might want to know how many results there are. For performance, they are not included by default. Request them explicitly with include_counts flag.

Copy
{
  "query": ...,
  "include_counts": true,
}
In the response, you'll get a count object.

Copy
{
  "data": [...],
  "count": {
    "limited": 3,
    "total": 3
  }
}
If you don't need the actual results but only care about the number, set the results_limit to zero.

Copy
{
  "query": ...,
  "include_counts": true,
  "results_limit": 0
}
In the response, the total count is the number you're interested in.

Copy
{
  "data": [],
  "count": {
    "limited": 0,
    "total": 3
  }
}
Sorting
You can sort the objects returned using a sort field whose value is a list of fields and their respective sort directions. In this example, we sort Contacts by title.

Copy
{
  "query": ...,
  "sort": [
    {
      "direction": "asc",
      "field": {
        "object_type": "contact",
        "type": "regular_field",
        "field_name": "title"
      }
    }
  ]
}
Sorting can be in either asc or desc direction.

Only numbers, dates, and text fields that belong directly to an object can be used for sorting. References/ID fields or fields from other objects cannot be used for sorting.

Pagination
A single request only returns a page worth of results. You can control how many results you want on one page using the _limit field, and ask for the next pages by sending the cursor field populated with a value from a previous response.

Copy
{
  "query": ...,
  "_limit": 10,
  "cursor": "<random string>" // <- cursor value from previous response
}
When the cursor value you're received in your most recent response is null, it means that you've reached the last page and no more results are available.

Cursors expire after 30 seconds; if you try to use an expired cursor you'll get an Expired cursor error.

We have a hard limit of 10,000 objects when paginating. If you need to paginate for more than 10,000 results, update your query to return smaller batches of objects. A popular method to do this would be to use the date_created field as a range, and make multiple requests while incrementing or decrementing the date.

Note: When paginating, be sure to use a sort that won’t change often like date_created, so that you won’t miss any results if the sort order changes between individual page requests.

Available query types
ID query
Matches a single object directly by its ID.

Copy
{
  "type": "id",
  "value": "cont_abcdef"
}
Object type
Specify the object type that the API should return (i.e. contact or lead)

Copy
{
  "object_type": "contact",
  "type": "object_type"
}
Text query
Filter for text across most text-like fields on an object.

Copy
{
  "type": "text",
  "value": "Bruce",
  "mode": "full_words"
}
The two available modes are:

full_words searches all specified words anywhere in the text but disregards position of the words.
phrase searches the words in specified order next to each other.
Has related
A has_related query lets you filter for a Contact based on data of the Lead they belong to, as well as individual email address and phone number records.

Copy
{
"type": "has_related",
"this_object_type": "contact",
"related_object_type": "lead",
"related_query": {
  "field": {
    "object_type": "lead",
    "type": "regular_field",
    "field_name": "source"
  },
  "condition": ...,
}
Query negation
All queries support negation. By specifying "negate": true, everything that matches the query will not be returned, and everything that doesn't match the query will.

Combining queries with AND/OR
To get objects that match multiple conditions all at once (AND) or at least one of the conditions, use and/or queries.

Copy
{
  "type": "and",
  "queries": [
    query1, query2, query3
  ]
}
{
  "type": "or",
  "queries": [
    query1, query2, query3
  ]
}
Field Value Condition Query
Match Contacts where the value in a specific field fits the Field Condition.

Copy
{
  "type": "field_condition",
  "field": {
    "type": "regular_field",
    "object_type": "contact",
    "field_name": "emails_count"
  },
  "condition": {
    "type": "number_range",
    "gt": 1
  }
}
There can be two field types: regular fields and custom fields.

Copy
{
  "field": {
    "type": "regular_field",
    "object_type": "contact",
    "field_name": "name"
  }
}
Custom fields:

Copy
{
  "field": {
    "type": "custom_field",
    "custom_field_id": "cf_abcdef"
  }
}
If you're unsure what query type to use, try the Visual Query Builder.

Field Conditions
Field Conditions are conditions that apply to individual field values as opposed to entire object.

Boolean
A yes/no value.

Copy
{
  "type": "boolean",
  "value": true
}
Current user
Represents a reference to a currently authenticated user, also known as "me". Use with fields like created_by.

Copy
{ "type": "current_user" }
Exists
Matches if the field is set to some value. Null or missing fields do not match.

Copy
{ "type": "exists" }
Text
Filters for text in the field value. Similar to Text query.

Copy
{
  "type": "text",
  "value": "Bruce",
  "mode": "full_words"
}
Term
Matches one or multiple specific Enumeration or Choices values.

Copy
{
  "type": "term",
  "values": ["draft", "sent"]
}
Reference
Matches specific object IDs in reference fields like User ID or Lead Status IDs.

Copy
{
  "type": "reference",
  "reference_type": "user",
  "object_ids": ["user_abc", "user_def"]
}
Most commonly used fields
For Contact: Object type: contact

created_by: User ID
date_created: datetime
date_updated: datetime
emails_count: integer
lead_id: Lead ID
phones_count: integer
title: text
updated_by: User ID
urls_count: integer
For Lead: Object type: lead

addresses_count: integer
all_urls_count: integer
created_by: User ID
date_created: datetime
date_updated: datetime
description: text
display_name: text
status_id: Lead Status ID
updated_by: User ID
url: url
For Contact Phones: Object type: contact_phone

type: text
phone: text
For Contact Emails: Object type: contact_email

type: text
email: email address
For Contact URLs: Object type: contact_url

type: text
url: url
For Addresses: Object type: address

address_1: text
address_2: text
city: text
country: text
location: text
state: text
zipcode: text

Custom Fields
Custom Fields let you store arbitrary data on Leads, Contacts, Opportunities, and Custom Activities.

When creating a Custom Field, you define its name, the type of data that's going to be stored on it, whether it can store multiple values or not, who in your organization can edit its values, etc. In other words, you fully control how it's going to be displayed in the Close UI and how its values are going to be validated and stored. This allows you to adjust your Close data to fit your sales process perfectly. Learn more about Custom Fields.

There are several endpoints that you can use to manage your Custom Fields:

Lead Custom Field API (/custom_field/lead/) – manage regular Custom Fields assigned to Leads.
Contact Custom Field API (/custom_field/contact/) – manage regular Custom Fields assigned to Contacts.
Opportunity Custom Field API (/custom_field/opportunity/) – manage regular Custom Fields assigned to Opportunities.
Activity Custom Field API (/custom_field/activity/) – manage regular Custom Fields assigned to a specific Custom Activity.
Shared Custom Field API (/custom_field/shared/) – manage Shared Custom Fields. These are Custom Fields that can be associated with one or more objects. For example, a single Shared Custom Field can be assigned to Leads, and several different Custom Activities.
Shared Custom Field Association API (/custom_field/shared/{cf_id}/association/) – manage which objects a given Shared Custom Field is associated with and control some of the association-specific properties (e.g. whether a value for the given Field should be required on the given object).
Custom Field Schema API (/custom_field_schema/{object_type}/) – efficiently fetch all (regular and shared) Custom Fields and control the order in which they're going to be displayed in the UI. We recommend this endpoint for fetching Custom Fields available in your organization.
A Custom Field has the following attributes:

name – the user-readable name of this Field.
description – a longer description of the Field that may be shown to users for context. The description may be null and has a 280 character limit.
type – determines the data type of the values that can be stored on this Field. The available types are:
text: accepts any text value, e.g. "Some Value".
number: accepts numeric values - both integers and decimals, e.g. 2 or 5.5.
date: accepts date values (without the time component), e.g. "2014-06-12".
datetime: accepts date values (including the time component), e.g. "2014-06-27T22:00:00-08:00".
choices: accepts only the values that are specified in the choices field of this Custom Field, e.g. "some valid choice".
user: accepts IDs (recommended) and names (exact match only) of Users who are active or former members of your organization (e.g. "user_asdflkjlkdsg3FHYQcUwV7tbwZRpe3sA215Ftv8OvbU" or "John Doe") and always returns IDs.
contact: accepts IDs of Contacts, limited to the Contacts that exist on the Lead you're editing:
If you're editing a Lead, only Contacts belonging to this Lead are accepted.
If you're editing a Contact, only Contacts belonging to the Lead that this Contact belongs to are accepted.
If you're editing a Custom Activity, only Contacts belonging to the Lead that this Custom Activity belongs to are accepted.
textarea: accepts any text value (just like the text type), but displays a multi-line textarea in the Close UI. Currently, this type of a Custom Field is only supported on Custom Activities.
hidden: accepts any value but is never shown in the UI. It's a good place to store information useful only to API integrations.
choices – a list of valid values for a choices type Custom Field.
accepts_multiple_values – determines if multiple values can be assigned to this Custom Field. Multiple values are currently only supported for the user, choices, and contact type Custom Fields.
editable_with_roles – list of Roles that can edit the values of this Custom Field. Empty if the editing is not restricted.
Note that you can only create/edit/delete Custom Fields if your User's Role has the manage_organization permission.

Phone Numbers
This endpoint shows you all the phone numbers that exist in your organization and lets you rent new numbers. It lets you label them and configure their settings.

There are a few types of phone numbers:

internal - means the number is owned and controlled by Close.
external - the number is owned by you and can only be used for outbound Close calls as a caller ID (e.g. it could be your company cell phone number).
virtual - the number is owned by you, but the calls are routed to Close via BYOC.
Whether a given phone number belongs to an individual user or to a group of users is determined by the is_group_number boolean. Learn more about group numbers.

If a given phone number is a group number, it will list all of its participating users' IDs in participants and all of the participating phone numbers in phone_numbers.

List or search for phone numbers.
GET /phone_number/{?number, user_id, is_group_number}

Example Request/Response
Retrieve a single phone number.
GET /phone_number/{id}/

Example Request/Response
Update a phone number.
PUT /phone_number/{id}/

You need the "Manage Group Phone Numbers" permission to update a group number. You can only update your own personal numbers.

You can:

Change a label of your number.
Set up call forwarding via forward_to and forward_to_enabled.
Set up a voicemail greeting by including a URL of an mp3 recording in voicemail_greeting_url. We require the URL to be secure (i.e. starting with https://).
Modify which team members are part of a group number via participants. This should be a list of user IDs.
Modify which external phone numbers are part of a group number via phone_numbers. This should be a list of phone numbers in E.164 international format, e.g. "+16503334444".
Example Request/Response
Delete a phone number.
DELETE /phone_number/{id}/

You need the "Manage Group Phone Numbers" permission to delete a group number. You can only delete your own personal numbers.

Example Request/Response
Rent an internal phone number.
POST /api/v1/phone_number/request/internal/

Renting a phone number incurs a cost. You need the "Manage Group Phone Numbers" permission to rent group numbers.

Accepts the following fields:

country (required): A two letter ISO country code (e.g. US for United States).
sharing (required): personal for a number that belongs to an individual user, or group for a group number.
prefix (optional): A string with the phone number prefix or area code, not including the country code.
with_sms (optional): By default, SMS-capable numbers are rented if Close supports SMS for the given country. Renting an SMS-capable number can be forced by setting this flag to true. If set to false, certain prefixes that don't support SMS can be rented in countries where Close supports SMS. In most scenarios, this flag should not be passed unless a has-voice-only error status is received (see below).
with_mms (optional): By default, MMS-capable numbers are rented if Close supports MMS for the given country. Renting an MMS-capable number can be forced by setting this flag to true. If set to false, certain prefixes that don't support MMS can be rented in countries where Close supports MMS. In most scenarios, this flag should not be passed.
If a number was rented, a 201 response is returned with the new number. If no number was rented (4xx response code), the response contains a status field which may contain one of the values below. New statuses may be added in the future.

has-voice-only: This country/prefix combination only has non-SMS-capable numbers. You can attempt renting the number by passing with_sms as false.
needs-more-info: More information (such as proof of address) is needed to rent this number. This number can only be rented by contacting Close support.
billing-error: An error related to billing has occurred. For example, the telephony budget has been reached, or there are not enough funds and recharging failed.
error: An error has occurred while renting this number. A human-readable message is returned in the error field.

Custom Activities
Custom Activities let you create arbitrary activity types with user defined fields. To work with Custom Activities, you will need to create a Custom Activity Type and likely add one or more Activity Custom Fields to that type. Once the Custom Activity Type is defined, you can create Custom Activity instances of that type as you would any other activity.
